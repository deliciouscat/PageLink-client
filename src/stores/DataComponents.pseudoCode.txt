# BookMark System Pseudo Code
# 계층적 북마크 관리 시스템 - Composite Pattern 기반

# ===========================
# 1. 공통 인터페이스 정의
# ===========================

Interface FileSystem(
    Properties(
        id: string,
        passage: string,
        visible: boolean,
        createdAt: DateTime
    ),
    Functions(
        updateVisible(searchTerm?: string) -> boolean
    )
)

# ID 생성 헬퍼 함수
Function generateId() -> string(
    Input: 없음
    Output: 고유 ID 문자열
    Logic: 현재 시간 + 랜덤값을 조합하여 고유 ID 생성
)

# ===========================
# 2. 추상 LeafNode 클래스
# ===========================

Abstract Class LeafNode {implements: FileSystem}(
    Properties(
        id: string,
        passage: string,
        visible: boolean,
        createdAt: DateTime
    ),
    
    Constructor(
        Input: passage: string
        Logic: 
            - id = generateId()
            - this.passage = passage
            - visible = true (기본값)
            - createdAt = 현재시간
    ),
    
    Functions(
        updateVisible(searchTerm?: string) -> boolean {
            Input: searchTerm - 검색어 (선택적)
            Output: visible 상태 (boolean)
            Logic:
                IF searchTerm이 비어있거나 null이면
                    visible = true
                ELSE
                    visible = passage에 searchTerm이 포함되는지 여부 (대소문자 무시)
                RETURN visible
        }
    )
)

# ===========================
# 3. Document 클래스 (Leaf)
# ===========================

Class Document {extends: LeafNode}(
    Properties(
        id: string (inherited),
        passage: string (inherited),
        visible: boolean (inherited),
        createdAt: DateTime (inherited),
        tags: list[string]
    ),
    
    Constructor(
        Input: 
            - passage: string
            - tags: list[string] (기본값: 빈 배열)
        Logic:
            - 부모 생성자 호출(passage)
            - this.tags = tags
    )
)

# ===========================
# 4. Collection 클래스 (Composite)
# ===========================

Class Collection {implements: FileSystem}(
    Properties(
        id: string,
        passage: string,
        visible: boolean,
        children: list[LeafNode],
        createdAt: DateTime
    ),
    
    Constructor(
        Input: passage: string
        Logic:
            - id = generateId()
            - this.passage = passage
            - visible = true (기본값)
            - children = 빈 배열
            - createdAt = 현재시간
    ),
    
    Functions(
        addItem(item: LeafNode) -> void {
            Input: item - 추가할 LeafNode
            Output: 없음
            Logic: children 배열에 item 추가
        },
        
        removeItem(item: LeafNode) -> void {
            Input: item - 제거할 LeafNode
            Output: 없음
            Logic: children 배열에서 item 제거
        },
        
        removeItemById(id: string) -> boolean {
            Input: id - 제거할 아이템의 ID
            Output: 제거 성공 여부
            Logic: 
                해당 ID를 가진 child를 찾아서 제거
                제거되면 true, 없으면 false 반환
        },
        
        updateVisible(searchTerm?: string) -> boolean {
            Input: searchTerm - 검색어 (선택적)
            Output: visible 상태
            Logic:
                IF searchTerm이 비어있거나 null이면
                    visible = true
                    모든 children에 대해 updateVisible() 호출
                ELSE
                    selfMatches = 자신의 passage에 searchTerm 포함 여부
                    hasVisibleChildren = children 중 하나라도 updateVisible(searchTerm) == true
                    visible = selfMatches OR hasVisibleChildren
                RETURN visible
        },
        
        getVisibleChildren() -> list[LeafNode] {
            Input: 없음
            Output: visible한 children 배열
            Logic: children 중 visible == true인 것들만 필터링하여 반환
        },
        
        getItemsByType<T>(type: Class<T>) -> list[T] {
            Input: type - 필터링할 클래스 타입
            Output: 해당 타입의 children 배열
            Logic: children 중 지정된 타입의 인스턴스만 필터링하여 반환
        },
        
        getItemCounts() -> object {
            Input: 없음
            Output: { documents: number, total: number }
            Logic:
                documents = Document 타입 children 개수
                total = 전체 children 개수
                반환
        }
    )
)

# ===========================
# 5. 상태 관리 Store
# ===========================

Store FileSystemStore(
    State(
        collections: list[Collection] = [],
        searchTerm: string = '',
        isSearching: boolean = false,
        selectedCollectionId: string? = null,
        selectedItemId: string? = null
    ),
    
    Computed(
        visibleCollections() -> list[Collection] {
            Output: visible한 컬렉션들
            Logic: collections 중 visible == true인 것들만 반환
        },
        
        selectedCollection() -> Collection? {
            Output: 현재 선택된 컬렉션 또는 null
            Logic: selectedCollectionId로 컬렉션 찾아서 반환
        },
        
        totalItemCount() -> number {
            Output: 전체 아이템 개수
            Logic: 모든 컬렉션의 children 개수 합계
        },
        
        visibleItemCount() -> number {
            Output: 현재 visible한 아이템 개수
            Logic: 모든 컬렉션의 visible children 개수 합계
        },
        
        allItemCounts() -> object {
            Output: { documents: number, total: number }
            Logic: 모든 컬렉션의 아이템 개수를 타입별로 집계
        }
    ),
    
    Actions(
        createCollection(name: string) -> Collection {
            Input: name - 컬렉션 이름
            Output: 생성된 컬렉션
            Logic: 
                새 Collection 생성하여 collections에 추가
                생성된 컬렉션 반환
        },
        
        removeCollection(collectionId: string) -> boolean {
            Input: collectionId - 삭제할 컬렉션 ID
            Output: 삭제 성공 여부
            Logic:
                해당 ID의 컬렉션을 collections에서 제거
                선택된 컬렉션이었다면 선택 해제
                성공 여부 반환
        },
        
        selectCollection(collectionId: string?) -> void {
            Input: collectionId - 선택할 컬렉션 ID (null이면 선택 해제)
            Output: 없음
            Logic:
                selectedCollectionId 업데이트
                selectedItemId 초기화 (null)
        },
        
        addDocument(collectionId: string, passage: string, tags: list[string]) -> Document? {
            Input: 
                - collectionId: 대상 컬렉션 ID
                - passage: 문서 내용
                - tags: 태그 배열 (기본값: 빈 배열)
            Output: 생성된 Document 또는 null
            Logic:
                해당 컬렉션 찾기
                새 Document 생성 후 컬렉션에 추가
                현재 검색 중이면 visible 상태 업데이트
                생성된 Document 반환
        },
        
        addItem(collectionId: string, item: LeafNode) -> boolean {
            Input:
                - collectionId: 대상 컬렉션 ID
                - item: 추가할 LeafNode
            Output: 추가 성공 여부
            Logic:
                해당 컬렉션에 item 추가
                현재 검색 중이면 item의 visible 상태 업데이트
        },
        
        removeItem(collectionId: string, itemId: string) -> boolean {
            Input:
                - collectionId: 대상 컬렉션 ID
                - itemId: 삭제할 아이템 ID
            Output: 삭제 성공 여부
            Logic: 해당 컬렉션에서 아이템 제거
        },
        
        selectItem(itemId: string?) -> void {
            Input: itemId - 선택할 아이템 ID (null이면 선택 해제)
            Output: 없음
            Logic: selectedItemId 업데이트
        },
        
        search(term: string) -> void {
            Input: term - 검색어
            Output: 없음
            Logic:
                searchTerm, isSearching 상태 업데이트
                모든 컬렉션과 아이템의 visible 상태 업데이트
        },
        
        clearSearch() -> void {
            Input: 없음
            Output: 없음
            Logic:
                검색 상태 초기화
                모든 항목을 visible로 복원
        },
        
        getCollectionById(id: string) -> Collection? {
            Input: id - 찾을 컬렉션 ID
            Output: 해당 컬렉션 또는 null
            Logic: collections에서 ID로 검색
        },
        
        getItemById(itemId: string) -> LeafNode? {
            Input: itemId - 찾을 아이템 ID
            Output: 해당 아이템 또는 null
            Logic: 모든 컬렉션의 children에서 ID로 검색
        },
        
        moveItem(itemId: string, fromCollectionId: string, toCollectionId: string) -> boolean {
            Input:
                - itemId: 이동할 아이템 ID
                - fromCollectionId: 출발 컬렉션 ID
                - toCollectionId: 목표 컬렉션 ID
            Output: 이동 성공 여부
            Logic:
                출발 컬렉션에서 아이템 제거
                목표 컬렉션에 아이템 추가
        },
        
        reset() -> void {
            Input: 없음
            Output: 없음
            Logic: 모든 상태를 초기값으로 재설정
        },
        
        generateSampleData() -> void {
            Input: 없음
            Output: 없음
            Logic:
                테스트용 샘플 컬렉션과 문서들 생성
                - 뉴스, 기술 문서, 프로젝트 문서 컬렉션
                - 각 컬렉션에 태그가 있는 문서들 추가
        }
    )
)

# ===========================
# 6. 핵심 설계 원칙
# ===========================

Design Patterns Used:
- Composite Pattern: Collection과 LeafNode의 계층 구조
- Abstract Factory: LeafNode 추상 클래스를 통한 공통 기능 제공
- Observer Pattern: 반응형 상태 관리를 통한 UI 업데이트

Key Features:
- 고유 ID 시스템으로 효율적인 아이템 관리
- 태그 시스템으로 분류 및 검색 기능 강화
- 실시간 검색 및 필터링
- 타입 안전성을 고려한 제네릭 메서드
- 컬렉션 간 아이템 이동 지원
- 상태 관리와 UI 로직 분리

Search Algorithm:
1. 검색어가 없으면 모든 항목 visible = true
2. 검색어가 있으면:
   - Document: 자신의 passage에 검색어 포함 여부로 visible 결정
   - Collection: 자신의 passage 매칭 OR 하나 이상의 child가 visible이면 visible = true
3. 상위에서 하위로 재귀적으로 visible 상태 전파